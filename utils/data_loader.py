import torch
import torchvision.transforms as transforms
from PIL import Image
from utils.fft_filter import fft_filter_2D

# GPU
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# mean and std for image-to-tensor normalization
cnn_norm_mean = [0.485, 0.456, 0.406]
cnn_norm_std = [0.229, 0.224, 0.225]
cnn_normalizer = transforms.Normalize(mean=cnn_norm_mean, std=cnn_norm_std)

# mean and std for tensor-to-image de-normalization 
cnn_norm_back_mean= [-0.485/0.229, -0.456/0.224, -0.406/0.225]
cnn_norm_back_std= [1/0.229, 1/0.224, 1/0.225]
cnn_denormalizer = transforms.Normalize(mean=cnn_norm_back_mean, std=cnn_norm_back_std)

# load image, pre-process it and transform it into tensor
def image_loader(image_name, imsize = None, tiling = (1,1), freq_lower = None, fft_level = 0, freq_upper = None, grayscale = False, mask = False):
    """
    Load image, pre-process it and transform it into tensor.
    Arguments:
        image_name: path to image
        imsize: resize image, can be None, integer or 2-tuple of integers
        tiling: tiling image, can be integer or 2-tuple of integers
        fft_level: apply FFT filter on which feature level, 0 means image level
        freq_lower: FFT high pass filter threshold
        freq_upper: FFT low pass filter threshold
        grayscale: whether to transform RGB image to grayscale and later duplicate over RGB channels, boolean
        mask: whether the loaded image is a mask, boolean
    Returns:
        when mask is False: a batch of single image tensor, with shape (1,3,M,N)
        when mask if True: a batch of single image tensor, with shape (1,M,N) 
    
    """
    # load image
    image = Image.open(image_name)

    # RGB to grayscale
    image = image.convert('L') if grayscale else image

    # tiling can be integer or 2-tuple of integers. An integer n as tiling is equivalent to a tuple of (n,n)
    tiling = (tiling, tiling) if isinstance(tiling, int) else tiling
    if tiling != (1,1):
        width_repeat = tiling if isinstance(tiling, int) else tiling[0]
        height_repeat = tiling if isinstance(tiling, int) else tiling[1]
        tiled_image = Image.new(image.mode, (image.width * width_repeat, image.height * height_repeat))
        for width_offset in range (0, image.width * width_repeat, image.width):
            for height_offset in range (0, image.height * height_repeat, image.height):
                tiled_image.paste(image, (width_offset, height_offset))
        image = tiled_image
    
    # resize image and transform into tensor
    loader_help = transforms.ToTensor() if imsize is None else transforms.Compose([transforms.Resize(imsize), transforms.ToTensor()])   
    image = loader_help(image)

    # apply FFT filter
    image = fft_filter_2D(image, freq_lower = freq_lower, freq_upper = freq_upper) if fft_level==0 else image
    
    # duplicate grayscale for RGB channels
    if image.shape[0] == 1 and not mask:
        image = image.repeat(3,1,1)
    
    # tensor normalization
    if not mask:
        image = cnn_normalizer(image)
        image = image.unsqueeze(0)                                          
    
    return image.to(device, torch.float)

# transform tensor into PIL image
def image_unloader(tensor):
    """
    Transform tensor into PIL image.
    Arguments:
        tensor: a batch of single image, with shape (1,3,M,N)
    Returns:
        PIL image
    """
    t = tensor.data[0].cpu()
    t = cnn_denormalizer(t)
    t.clamp_(0, 1)
    img = transforms.ToPILImage()(t)
    return img

# pre-process tensor
def tensor_loader(tensor, mask = False):
    """
    Pre-process rendering tensor.
    Arguments:
        tensor: rendering generated by PyTorch3D differentiable renderer
        mask: whether the tensor is used as mask, boolean
    Returns:
        pre-processed tensor
    """
    if not mask:
        # len(shape)==3 --> rgb tensor, else grayscale tensor
        # PyTorch3D generates RGB rendering tensor of shape (M,N,3), but networks require tensor of shape (1,3,M,N)
        tensor = tensor.permute(2,0,1) if len(tensor.shape)==3 else tensor.repeat(3,1,1)
        tensor = cnn_normalizer(tensor)

    return tensor.unsqueeze(0).to(device, torch.float)